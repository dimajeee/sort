в 1960 году Тони Хоара разработал сортировку, которая впоследствии станет одной из самых изветсных и быстрых сортировок, модификации которых будут использованы во многих языках программирования
она имеет название быстрая сортировка
суть ее в том, чтобы мы выбрали один из элементов массива, относительно которого будут сортироваться все остальные элементы
пускай это будет элемент, находящийся прямо посередине
для этого мы разделим длину массива на 2 и округлим получившееся значение вниз
элемент, который мы получили таким способом, называется опорный
далее мы создаем два указателя left right, начало и конец массива
в циклах начинем идти с двух сторон навтсречу друг другу
задача левого указателя найти элемент, который окажется больше или равен опорному элементу
задача правого указателя наоборот найти элемент, который окажется меньше или равен опорному
на этом моменте сразу возникает вопрос зачем нам каждый раз останавливаться на элементах равых опорному, если их обмен абсолютно ничего не меняет
дело в том, что если бы мы пропускали такие элементы, продолжая идти по циклу, то в массива который бы полностью состоял из одинаковых элементов, мы бы просто вышли за его пределы, получив ошибку
наши два цикла нашил свои элементы и остановились
если мы посмотрим на все варианты пар, на которых наши указатели могут остановиться, то заметим, что это могут быть только либо элементы , стоящие не на своих местах, то есть левый окажется больше правого, либо элементы, равные опорному, и следовательно равные друг другу
в первом случае нужно просто поменять элементы местами и сдвинуть указатели на одну позицию дальше
во втором случае достаточно просто сдвинуть указатели без их обмена
существуют случаи, когда бессмысленные действия помогают нам упростить код, а следовательно его понимание, при этом никак не ломая сам алгоритм работы, сейчас тот самый случай, когда мы можем избавиться от лишнего if и просто всегда менять элементы местами
наш код поменял лишь одну единственную пару местами, но он точно также как и в предыдущим сортировках является всего лишь одной частью от общей работы алгоритма
эту часть нужно повторять в цикле до тех пор пока все неверно стоящие пары не будут поменяны
но до какого условия нужно крутить цикл?
может показаться, что стоит это делать до тех пор, пока указатели не дойдут до опорного элемента
однако полагаться на него нам явно не стоит
во-первых, опорных элементов в массиве может быть сразу несколько, то есть не факт, что мы дошли именно до этой самой середины
во-вторых, опорный элемент тоже может быть поменян местами с другим элементом и так как мы передвигаем указатели дальше, до опорного элемента мы можем уже не дойти впринцпе
на что действительно важно обратить свое внимание, так это на сами указатели
сейчас они беспрепятственно двигаются навстречу друг другу, это значит, что они рано или поздно встретятся
место их встречи это стык, на котором можно провести четкую границу, слева от которой должны находится все элементы меньше или равные опорному, а справа больше или равные опорному
то есть на момент их встречи мы можем получить два конкретных подмассива
зачем они нам нужны? будет понятнее позже
сейчас же наша задача как-то отделить эти два подмассива друг от друга с помощью индексов
то есть левый подмассив будет от 0 до какого-то значения, а правый от какого-то значения до конца
может показаться, что этим значением будет являться сам стык, еще может показаться, что стыком будет являться то место, на которое одновременно будет указывать как указатель left, так и указатель rigth, однако это не всегда так
может получиться так, что left и rigth будут находится впритык друг к другу, а следовательно следующий сдвиг приведет к тому, что указатели просто перепрыгнут друг друга
является ли это проблемой? нет
сейчас важно понимать, что left и rigth встретились, значит все пары, которые находились не на своих местах, либо уже полностью обменялись своими значениями, либо обменяются прямо сейчас в самый последний раз
тогда теперь left будет указывать на самое начало правого подмассива, что нам собсвтенно и нужно
единтсвенное, что нам стоит понимать, так это-то, что сдвигаем мы указатели как в двух верхних while, так и после обмена элементов, поэтому может возникнуть ситуация, что сдвиг указателей после обмена приведет к тому самого стыку впритык
поэтому на следующей итерации внешнего цикла оба наших указателя перепрыгнут друг друга
а значит никаких обменов производить точно не нужно
поэтому весь этот обмен с последующим сдвигом мы оберачиваем соответсвующим if, который будет не допускать подобные ситуации
но как же все таки поведет себя код, если же все таки left и rigth на стыке будут указывать на один и тот же элемент
здесь сущестует два варианта
1) они указывают на опорный элемент
2) указывают не на опорный
если на опорный, то нужно ли вводить дополнительное условие, усложняя код и завершая внешний цикл на этом моменте? на самом деле нет
к примеру если такая ситуация попадется в наш if, то мы точно также можем произвести бесполезный обмен в пользу упрощения кода и точно также указателями перепрыгнуть друг друга
это не будет являться проблемой
потому что нам не важно с какой стороны будет находится опорный элемент
в случае если стык придется на два наших while, то они просто не выполнятся, потому что не сработают условия, мы снова зайдем в наш if и перепрыгнем указатели
только чтобы произошло то, о чем мы говорим, в условии if надо поставить знак <=
в случае если left и right будут указывать на один и тот же элемент, но он не будет являться опорным, что тогда?
во-перых, это не опорное значение может оказаться числом, которое либо больше опорного элемента, либо меньше
представим, что в эту ситуацию нас привел наш if
следовательно мы переходим на следующую итерацию внешнего цикла и смотрим
если это значение, на которое указывают указатели является меньше, чем опорное значение, значит left прыгнет, right нет
соответственно на этом мы и заканчиваем
потому что left вновь верно указывает на начало правого подмассива
если это значение оказывается больше или равно опорному, значит оно должно оказаться в правом подмассиве, left не прыгает, right прыгает
снова все верно, а это означает, что это текущее условие для if и циклов полностью подходит для всевозможных случаем
но что, если в это приведут нас два наших цикла while
на самом деле если такое произвошло, то означает, что указатели left и right всегда указывают на опорный элемент, пример с которым мы разбирали уже чуть ранее
разбор всех возможных вариантов, в которые нас может поставить наш код дает понять, что цикл нужно крутить до тех пор, пока left и right полностью не перепрыгнут друг друга
в таком случае left всегда будет указывать на начало правого подмассива, а значит левый подмассив всегда будет находиться в диапозоне от 0 до left - 1, а правый от left до конца
зачем нам вообще нужны эти два подмассива?
все просто, если мы взглянем на то, что у нас получилось, то увидим, что внутри себя эти два подмассива полностью еще не отсортированны
при этом весь левый полностью отсортирован относительно правого, то есть в том смысле что все его элементы меньше правых, а следовательно они и должны находиться слева
поэтому единтсвенное, что нам нужно сделать теперь это сделать все те же самые шаги, но для каждого из этих подмассивов
запускаем две рекурсии, которые будут снова и снова разбивать свои подмассивы на две части, постеменно их сортируя
условием выхода из рекурсии будет являться момент, когда массив, который передавается будет состоять всего из одного элемента, следовательно сортировать нечего
как мы видим, сортировка Хоара содержит много неочевидных моментов, которые нужно учитывать при написании этого алгоритма