чтобы сравнить все элементы массива, очевидно, что их нужно перебрать через цикл
на каждой итерации мы будем сравнивать текущий элемент с предыдущим и если предыдущий элемент оказывается больше текущего, то меняем их местами, перемещая тем самым большие значения вправо, а меньшие влево
однако посмотрев на массив после завершения цикла мы видим, что он по прежнему остается не отсортированным
на самом деле один проход по циклу это лишь одна фаза целого алгоритма, суть которого поставить самый старший элемент массива на свое место в самом конце
получается, что нам нужно столько раз, сколько потребуется для того, чтобы все элементы массива встали на свое место
поэтому запускаем бесконечный цикл while и внутри него продолжаем выполнять цикл for
при этом перебирать каждый раз весь массив полностью никакой необходимости нет, последний элемент уже после всего находится на своем месте
поэтому во втором проходе достаточно будет перебрать массив длина которого будет меньше, но меньше на сколько?
чтобы ответить на этот вопрос стоит понимать, что в if мы попадем только тогда, когда найдем максимальный элемент из всех, который находится не на своем месте
соответственно, если мы туда не попадаем, то значит текущие сравниваемые элементы на своем месте
все это означает, что после последнего элемента с индексом i, который попадет в наш if, все элементы будут уже отсортированны в правильном порядке
следовательно на следующей итерации цикла нам нужно перебать массив только до этого i
в итоге когда массив станет полностью отсортированным, переставлять будет нечего и if не выполнится, то длина перебора окажется равной нулю, следоватьельно наша функция завершится